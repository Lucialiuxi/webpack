1. 打包上线过程
	a. 打包 npm run build
	b. 上传服务器 ftp协议 pm2是node模块
	c. 路径 手动上传，手动设置
		打包时候，加上基本路径
			config目录下
				index.js
					build配置
						 // Paths
						    assetsRoot: path.resolve(__dirname, '../dist'),  // 生成的目录名字
						    assetsSubDirectory: 'miaov',  // 静态目录名字
						    assetsPublicPath: '/cnnode/', // 相对路径
						    	把index.html引入css、js在前面都会加上这个路径

2. 单页应用刷新出现404
	单页应用：无论使用哪个地址访问，都应该访问的是index.html

	正常点击导航跳转的时候，是正常的，因为并没有刷新页面，一直访问的是index.html
	路径因为浏览器提供的history功能

	上线了：访问：http://localhost:3000/detail/5ab34443e7b166bb7b9ecd06

		找到的服务器上这个路径对应的目录
		服务器上并没有以上的目录，404

	服务器的路径和浏览器的history功能冲突了？？？？

	解决：无论访问那个路径，在服务端都设置成指向index.html,
			指向了index.html，那么就有程序来处理当前这个路径对应的组件

3. 在服务端配置，举例Apache
		以wamp为例子

		1. 取消一个模块的注释 http.cof
			LoadModule rewrite_module modules/mod_rewrite.so
		2. 网站的根路径，设置一个文件
			.htaccess 文件
			写入内容：
				<IfModule mod_rewrite.c>
				  RewriteEngine On
				  RewriteBase /
				  RewriteRule ^index\.html$ - [L]
				  RewriteCond %{REQUEST_FILENAME} !-f
				  RewriteCond %{REQUEST_FILENAME} !-d
				  RewriteRule . /cnnode/index.html [L]
				</IfModule>

总结以上：单页应用的时候，上传到服务上，刷新不出现404，要在服务端配置指向index.html

webpack
---------------------------------
官网：https://webpack.js.org/
中文：https://www.webpackjs.com/

webpack 是一个现代 JavaScript 应用程序的 静态 模块打包器(module bundler)
当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。

入口(entry)
输出(output)
loader
插件(plugins)

操作：
-----------------------
安装webpack：
	npm i --save-dev（-D） webpack@3.11.0 wepack-cli

	看版本：https://github.com/webpack/webpack/releases

	这不是全局安装,是局部的，不能再命令窗口中使用命令，webpack

	要使用npm 的 scripts
		{
			"dev": "webpack"  // 回去找node_modudles下的bin目录  
		}

	跑这个命令：npm run dev

	已经在全局安装一个版本为2版本，某个项目需要用3版本，其他项目只能使用2版本
		npm i vue-cli@2.1.1 -g
		npm i jquery@2.8.2 -g

webpack配置
------------------------

在项目目录创建js文件webpack.config.js
	module.exports = {
		entry:  入口
		output: { 出口
			path: 绝对路径
			filename: 名字
		}

		module:{
			rules: 处理各种的loader

			[
				{
					test: 正则 /\.css$/  /\.sass$/ /\.less$/ /\.(png|jpg)$/
					第一种写法：use:['style-loader','css-loader'] 从后向前执行
					第二种写法：use:[
						{
							loader: 'css-loader',
							options:{}
						},
						{
							loader: 'style-loader'
						}
					]
				}
			]
		}
		resolve:{},
		devServer:{},
		plugins:[

		] 插件
	}



loader
----------
webpack默认只处理js文件
------------------------
处理各种各样的资源 css sass less png

处理css
	style-loader 把html生成一个style标签
	css-loader 处理文件的语法

	安装：npm i css-loader style-loader -D

处理sass
	安装：npm i sass-loader node-sass -D
处理less
	安装：$ npm install less-loader less --save-dev

处理图片
	file-loader 处理图片
	url-loader 处理图片
		转成base64格式 减少http请求

插件
-------------------------

清空指定目录：
	npm install clean-webpack-plugin --save-dev

	let cleanWebpackPlugin = require('clean-webpack-plugin')

	[
		new cleanWebpackPlugin(['dist'])
	]


打包后的文件
	一堆的代码，是webpack的runtime，webpack的运行环境


解决的问题：
	1. index.html中引入js或css，现在手动引入，自动引入
		生成html的插件
		var HtmlWebpackPlugin = require('html-webpack-plugin');
		plugins:[
			new HtmlWebpackPlugin({
		      title: '项目',
		      template: 'index.html',  // 模板
		      filename: 'index.html',  // 生成后的html
		      inject: true,
		      //chunks
		    })
		]


	2. 本地搭建一个开发服务器环境
		很接近真实的生产环境访问，一些http的请求能更加真实

		npm i webpack-dev-server@2.11.1 -D

		webpack-dev-server@2.11.1使用在webpack3.X版本
		webpack-dev-server@3X使用在webpack4.X版本

		webpack-dev-server --inline --progress --config webpack.server.js 

		不会打包，只是启动服务，所需要的html，css，js都是在内存中

		devServer:{
			port: 9000
			hot: true
		}



	3. 热加载，live reloading

		webpack-dev-server在更改js，css会刷新页面 live reloading

		启动热加载：
			if(module.hot){
			  module.hot.accept();
			}

		使用vue-cli create-react-app 这些工具，里面就有热更新

	4. 打包上线需要把css抽离成独立的文件

		npm install --save-dev extract-text-webpack-plugin
		const ExtractTextPlugin = require("extract-text-webpack-plugin");

		rules: [
	      {
	        test: /\.css$/,
	        use: ExtractTextPlugin.extract({
	          fallback: "style-loader",
	          use: "css-loader"
	        })
	      }
	    ]

	    plugins: [
		    new ExtractTextPlugin("styles.css"),
		  ]

	5. js抽离到单独的文件
		a. 多个模块公用的代码
		b. webpack runtime 公用的代码
		c. 第三方的模块 jq lodash



区分生产环境和开发环境
	在window系统下设置：set NODE_ENV=development 
	在linx系统下设置：

在webpack中区分生产环境和开发环境，方便在写的代码中在不同环境做不同事情：

	new webpack.DefinePlugin({
      'process.env': '"dev"'
    })

    process.env 将会成为源码中的全局变量

react环境
----------------
仓库：https://github.com/facebook/create-react-app

安装 npm i create-react-app -g

创建项目：create-react-app my-project

启动项目：npm start



